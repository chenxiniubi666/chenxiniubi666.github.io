<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring小记 | 底层Coder的狗窝</title><meta name="author" content="CoderChen"><meta name="copyright" content="CoderChen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring 小记摘抄自 Spring揭秘 BeanFactoryProcessor PropertyPlaceholderConfiguration: 帮助解析xml文件中的数据源配置内容  123456&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring小记">
<meta property="og:url" content="http://example.com/2022/05/16/Spring/Spring%20%E5%B0%8F%E8%AE%B0/index.html">
<meta property="og:site_name" content="底层Coder的狗窝">
<meta property="og:description" content="Spring 小记摘抄自 Spring揭秘 BeanFactoryProcessor PropertyPlaceholderConfiguration: 帮助解析xml文件中的数据源配置内容  123456&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg13.jpg">
<meta property="article:published_time" content="2022-05-16T20:00:00.000Z">
<meta property="article:modified_time" content="2022-05-16T21:00:00.000Z">
<meta property="article:author" content="CoderChen">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg13.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/05/16/Spring/Spring%20%E5%B0%8F%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring小记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-16 21:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg13.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="底层Coder的狗窝"><span class="site-name">底层Coder的狗窝</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring小记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-05-16T20:00:00.000Z" title="Created 2022-05-16 20:00:00">2022-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-05-16T21:00:00.000Z" title="Updated 2022-05-16 21:00:00">2022-05-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E6%97%A5%E8%AE%B0/">读书日记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/">Spring进阶之路</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>15min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring小记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring-小记"><a href="#Spring-小记" class="headerlink" title="Spring 小记"></a>Spring 小记</h1><p><strong>摘抄自 Spring揭秘</strong></p>
<h3 id="BeanFactoryProcessor"><a href="#BeanFactoryProcessor" class="headerlink" title="BeanFactoryProcessor"></a>BeanFactoryProcessor</h3><ol>
<li><code>PropertyPlaceholderConfiguration</code>: 帮助解析xml文件中的数据源配置内容</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在加载完所有<code>BeanDefinition</code>时，对象的属性信息还是以占位符的形式存在，当<code>PropertyPlaceholderConfiguration</code>作为<code>BeanFactoryPostProcessor</code>被应用时，会将相应的配置信息替换占位符。</p>
<ol start="2">
<li><code>PropertyOverideConfigurer</code>： 覆盖配置文件的信息</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyOverrideConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--替换为jdbc.properties中的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中jdbc.properties：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">beanName.propertyName</span>=<span class="string">value</span></span><br><span class="line"><span class="comment"># 也就是说把 某个bean的某个属性替换为value</span></span><br><span class="line"><span class="comment"># dataSource.maxActive=50</span></span><br></pre></td></tr></table></figure>

<p><code>PropertyPlaceholderConfiguration</code> 和 <code>PropertyOverideConfigurer</code> 都继承于 <code>PropertyResourceConfigurer</code>， 它提供了一个方法 <code>#convertProperties</code> 允许子类覆盖实现对相应配置项的转换，如将加密后的字符串进行揭秘后再覆盖到原有的bean中。</p>
<ol start="3">
<li><p><code>CustomEditorConfigurer</code>：辅助的将后期需要用到的信息注册到容器，也就是把各个属性对应的 <code>PropertyEditor</code> 注册到容器中，以供后面的 <code>BeanWrapper</code> 使用</p>
<p>用xml加载bean时，由于xml记载的都是String类型，想要完成字符串到具体对象的转换，就需要相应的转换规则，CustomEditorConfigurer 就是帮助我们做这些的</p>
<p>Spring内部通过 <code>PropertyEditor</code> 来帮助进行String类型转换到其它类型的工作，只要为每种对象提供一个 <code>PropertyEditor</code> ，就可以根据该对象类型取得其相应的 <code>PropertyEditor</code> 来做具体的转换。</p>
<ul>
<li><code>StringArrayPropertyEditor</code>：将符合CSV格式的字符串转换成String[]数组的形式，默认是以逗号分隔的字符串</li>
<li><code>ClassPropertyEditor</code>：根据String类型的class名称，直接转换成相应的Class对象</li>
<li>…</li>
</ul>
<p>比如我们现在有某个需求，系统的某个部分需要用yyyy-MM-dd的形式表现日期，但是另一个部分需要采用yyyyMMdd的形式表现日期，默认情况下我们没有这种转换模式，因此我们需要如何定义这种转换方式。</p>
<ol>
<li>给出针对特定对象类型的 PropertyEditor 的实现</li>
</ol>
<p>可以通过继承 java.beans.PropertyEditorSupport ，实现其 #setAsText 方法即可</p>
<ol start="2">
<li>通过 CustomEditorConfigurer 注册自定义的 PropertyEditor</li>
</ol>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/img/image-20220429114201577.png" alt="image-20220429114201577"></p>
<h4 id="Bean的初始化与BeanWrapper"><a href="#Bean的初始化与BeanWrapper" class="headerlink" title="Bean的初始化与BeanWrapper"></a>Bean的初始化与BeanWrapper</h4><p>分为<strong>实例化对象</strong>和<strong>设置对象属性</strong>两步</p>
<blockquote>
<p>实例化对象</p>
</blockquote>
<p>容器在内部实现的时候，采用“<strong>策略模式</strong>（Strategy Pattern）”来决定采用何种方式初始化bean实例。通常，可以通过<strong>反射或者CGLIB动态字节码</strong>生成来初始化相应的bean实例或者动态生成其子类。默认情况下，容器内部采用的是 <code>CglibSubclassingInstantiationStrategy</code>， 即通过CGLIB的动态字节码生成</p>
<p>容器只要根据相应bean定义的 <code>BeanDefintion</code> 取得实例化信息，结合 <code>CglibSubclassingInstantiationStrategy</code><br>以及不同的bean定义类型，就可以返回实例化完成的对象实例。但是，返回方式上有些“点缀”。不是直接返回构造完成的对象实例，而是以<code>BeanWrapper</code> 对构造完成的对象实例进行包裹，返回相应的 <code>BeanWrapper</code> 实例。</p>
<blockquote>
<p>设置对象属性</p>
</blockquote>
<p><code>BeanWrapper</code>定义继承了 <code>org.springframework.beans.PropertyAccessor</code> 接口，<strong>可以以统一的方式对对象属性进行访问</strong>；<code>BeanWrapper</code>定义同时又直接或者间接继承了<code>PropertyEditorRegistry</code>和<code>TypeConverter</code>接口。在第一步构造完成对象之后，Spring会根据对象实例构造一个<code>BeanWrapperImpl</code>实例，然后将之前<code>CustomEditorConfigurer</code>注册的<code>PropertyEditor</code><strong>复制</strong>一份给<code>BeanWrapperImpl</code>实例（这就是BeanWrapper同时又是PropertyEditorRegistry的原因）。这样，当BeanWrapper转换类型、设置对象属性值时，就不会无从下手了。</p>
<p><code>BeanWrapper</code> 作为 BeanDefinition 向 Bean 转换过程中的中间产物，承载了 Bean 实例的包装、类型转换、属性的设置以及访问等重要作用。</p>
<h4 id="检查Aware接口并设置相关依赖"><a href="#检查Aware接口并设置相关依赖" class="headerlink" title="检查Aware接口并设置相关依赖"></a>检查Aware接口并设置相关依赖</h4><ul>
<li><code>BeanNameAware</code>：会将该对象实例的bean定义对应的beanName设置到当前对象实例</li>
<li><code>BeanClassLoaderAware</code>：会将对应加载当前bean的Classloader注入当前对象实例</li>
<li><code>BeanFactoryAware</code>：BeanFactory容器会将自身设置到当前对象实例</li>
<li><code>ApplicationContextAware</code>：会将 <code>ApplicationContext</code> 注入当前对象实例</li>
</ul>
<h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><blockquote>
<p>前置处理</p>
</blockquote>
<p>通常比较常见的使用 <code>BeanPostProcessor</code> 的场景，是处理标记接口实现类，或者为当前对象提供代理实现。</p>
<p>当 <code>ApplicationContext</code> 中每个对象的实例化过程走到 <code>BeanPostProcessor</code> 前置处理这一步时，<code>ApplicationContext</code> 容器会检测到之前注册到容器的 <code>ApplicationContextAwareProcessor</code> 这个 <code>BeanPostProcessor</code> 的实现类，然后就会调用其<code>postProcessBeforeInitialization()</code> 方法，检查并设置Aware相关依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对之前实现了的Aware接口做一些操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware)bean).setEnvironment(<span class="built_in">this</span>.applicationContext.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">        ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(<span class="built_in">this</span>.embeddedValueResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">        ((ResourceLoaderAware)bean).setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">        ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">        ((MessageSourceAware)bean).setMessageSource(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationStartupAware) &#123;</span><br><span class="line">        ((ApplicationStartupAware)bean).setApplicationStartup(<span class="built_in">this</span>.applicationContext.getApplicationStartup());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware)bean).setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了检查标记接口以便应用自定义逻辑，还可以通过<code>BeanPostProcessor</code>对当前对象实例做更多的处理。比如替换当前对象实例或者字节码增强当前对象实例等.</p>
<p><code>InstantiationAwareBeanPostProcessor</code> ：在所有的步骤之前，也就是实例化bean对象步骤之前，容器会首先检查容器中是否注册有<code>InstantiationAwareBeanPostProcessor</code>类型的<code>BeanPostProcessor</code>。如果有，首先使用相应的<code>InstantiationAwareBeanPostProcessor</code>来构造对象实例。构造成功后直接返回构造完成的对象实例，而不会按照“正规的流程”继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="comment">// 用于实例化之前，如果该方法返回了一个beanClass的对象，则返回该对象而不进入之后的CreateBean阶段(依然会执行BeanPostProcessor.postProcessAfterInitialization)</span></span><br><span class="line">    <span class="meta">@Nullable</span>	<span class="comment">//对象初始化之前执行</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成实例化后执行，如果该方法返回了false,则跳过依赖注入阶段</span></span><br><span class="line">	<span class="comment">//对象初始化之后执行</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖注入之前执行，用于自定义的注值</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> PropertyValues <span class="title function_">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="InitializingBean和init-method"><a href="#InitializingBean和init-method" class="headerlink" title="InitializingBean和init-method"></a>InitializingBean和init-method</h4><p><code>InitializingBean</code> 是容器内部广泛使用的一个对象生命周期标识接口该接口定义很简单，其作用在于，<strong>在对象实例化过程调用过 “ <code>BeanPostProcessor</code> 的前置处理” 之后</strong>，会接着检测当前对象是否实现了 <code>InitializingBean</code> 接口，如果是，则会调用其<code>afterPropertiesSet()</code>方法进一步调整对象实例的状态。</p>
<p>虽然该接口在Spring容器内部广泛使用，但如果真的让我们的业务对象实现这个接口，则显得Spring容器比较具有侵入性。所以，Spring还提供了另一种方式来指定自定义的对象初始化操作，那就是在XML配置的时候，使用&lt;bean&gt;的init-method属性。</p>
<p>通过init-method，系统中业务对象的自定义初始化操作可以以任何方式命名，而不再受制于<code>InitializingBean</code>的<code>afterPropertiesSet()</code>。如果系统开发过程中规定：所有业务对象的自定义初始化操作都必须以init()命名，为了省去挨个&lt;bean&gt;的设置init-method这样的烦琐，我们还可以通过最顶层的&lt;beans&gt;的default-init-method统一指定这一init()方法名。</p>
<h4 id="DisposableBean与destroy-method"><a href="#DisposableBean与destroy-method" class="headerlink" title="DisposableBean与destroy-method"></a>DisposableBean与destroy-method</h4><p>当所有的一切，该设置的设置，该注入的注入，该调用的调用完成之后，容器将检查singleton类型的bean实例，看其是否实现了<code>DisposableBean</code> 接口。或者其对应的bean定义是否通过&lt;bean&gt;的 <code>destroy-method</code> 属性指定了自定义的对象销毁方法。如果是，<br>就会为该实例注册一个用于对象销毁的回调（Callback），以便在这些singleton类型的对象实例销毁之前，执行销毁逻辑。<br>与<code>InitializingBean</code>和<code>init-method</code>用于对象的自定义初始化相对应，<code>DisposableBean</code>和<code>destroy-method</code>为对象提供了执行自定义销毁逻辑的机会。最常见到的该功能的使用场景就是在Spring容器中注册数据库连接池，在系统退出后，连接池应该关闭，以释放相应资源。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>作为Spring提供的较之 <code>BeanFactory</code> 更为先进的IoC容器实现，<code>ApplicationContext</code> 除了拥有 <code>BeanFactory</code> 支持的所有功能之外，还进一步扩展了基本容器的功能.</p>
<h4 id="统一的资源加载策略"><a href="#统一的资源加载策略" class="headerlink" title="统一的资源加载策略"></a>统一的资源加载策略</h4><p>资源可以任何形式存在，如以二进制对象形式存在、以字节流形式存在、以文件形式存在等</p>
<p>资源也可以存在于任何场所，如存在于文件系统、存在于Java应用的Classpath中，甚至存在于URL可以定位的地方</p>
<p>Spring提出一套基于<code>Resource</code>和<code>ResourceLoader</code>接口的资源抽象和加载策略</p>
<p>常见的Resource：</p>
<ul>
<li><code>ByteArrayResource</code>：将字节（byte）数组提供的数据作为一种资源进行封装</li>
<li><code>ClassPathResource</code>：该实现从Java应用程序的ClassPath中加载具体资源并进行封装</li>
<li><code>FileSystemResource</code>：对java.io.File类型的封装</li>
<li><code>UrlResource</code>：通过java.net.URL进行的具体资源查找定位的实现类，内部委派URL进行具体的资源操作</li>
<li>…</li>
</ul>
<p>常见的ResourceLoader：</p>
<ul>
<li><code>DefaultResourceLoader</code><ul>
<li>首先检查资源路径是否以 <code>classpath:</code> 前缀打头，如果是，则尝试构造 <code>ClassPathResource</code> 类型资源并返回</li>
<li>尝试通过 <code>URL</code> ，根据资源路径来定位资源，如果没有抛出MalformedURLException，有则会构造 <code>UrlResource</code> 类型的资源并返回</li>
<li>如果还是无法根据资源路径定位指定的资源，则委派getResourceByPath(String) 方法来定位， <strong>DefaultResourceLoader 的getResourceByPath(String)方法默认实现逻辑是，构造ClassPathResource类型的资源并返回</strong></li>
</ul>
</li>
<li><code>FileSystemResourceLoader</code>：继承自 <code>DefaultResourceLoader</code>但覆写了getResourceByPath(String)方法，使之从文件系统加载资源并以 <code>FileSystemResource</code> 类型返回</li>
</ul>
<p>ResourceLoader的扩展：</p>
<p><code>ResourcePatternResolver</code>：批量查找的<code>ResourceLoader</code>。<code>ResourcePatternResolver</code>是<code>ResourceLoader</code>的扩展，<code>ResourceLoader</code>每次只能根据资源路径返回确定的<strong>单个</strong><code>Resource</code>实例，而<code>ResourcePatternResolver</code>则可以根据指定的资源路径匹配模式，每次返回<strong>多个</strong><code>Resource</code>实例。</p>
<ul>
<li><p><code>PathMatchingResourcePatternResolver</code>：该实现类支持<code>ResourceLoader</code>级别的资源加载，支持基于Ant风格的路径匹配模式（类似于**&#x2F;<em>.suffix之类的路径形式），支持<code>ResourcePatternResolver</code>新增加的classpath</em>:前缀等</p>
<p>在构造<code>PathMatchingResourcePatternResolver</code>实例的时候，可以指定一个<code>ResourceLoader</code>，如果不指定的话， 则<code>PathMatchingResourcePatternResolver</code>内部会默认构造一个<code>DefaultResourceLoader</code>实例</p>
</li>
</ul>
<blockquote>
<p>Resource和ResourceLoader关系</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/img/image-20220502142526102.png" alt="Resource和ResourceLoader"></p>
<blockquote>
<p>ApplicationContext与ResourceLoader</p>
</blockquote>
<p><code>ApplicationContext</code>继承了<code>ResourcePatternResolver</code>，当然就间接实现了<code>ResourceLoader</code>接口。所以，任何的<code>ApplicationContext</code>实现都可以看作是一个<code>ResourceLoader</code>甚至<code>ResourcePatternResolver</code></p>
<p>所有的<code>ApplicationContext</code>实现类会直接或者间接地继承org.springframework.context.support.<code>AbstractApplicationContext</code>，从这个类上，我们就可以看到<code>ApplicationContext</code>与<code>ResourceLoader</code>之间的所有关系。</p>
<ul>
<li>首先，<code>AbstractApplicationContext</code>继承了<code>DefaultResourceLoader</code>，所以它的 <code>#getResource(String)</code> 用的就是<code>DefaultResourceLoader</code>  –&gt; 它能做<code>ResourceLoader</code>的事情</li>
<li>其次，<code>AbstractApplicationContext</code>类的内部声明有一个<code>resourcePatternResolver</code>，类型是<code>ResourcePatternResolver</code>，对应的实例类型为<code>PathMatchingResourcePatternResolver</code>  –&gt; 它能做<code>ResourcePatternResolver</code>的事情</li>
</ul>
<p>说白了，<code>ApplicationContext</code>的实现类在作为<code>ResourceLoader</code>或者<code>ResourcePatternResolver</code>时候的行为，完全就是委派给了<code>PathMatchingResourcePatternResolver</code>和<code>DefaultResourceLoader</code>来做</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/img/image-20220502143609800.png" alt="ApplicationContext与ResourceLoader"></p>
<p><code>ApplicationContext</code>启动伊始，会通过一个org.springframework.beans.support.<code>ResourceEditorRegistrar</code>来注册Spring提供的针对<code>Resource</code>类型的<code>PropertyEditor</code>实现到容器中，这个<code>PropertyEditor</code>叫做org.springframework.core.io.<code>ResourceEditor</code>。这样， <code>ApplicationContext</code>就可以正确地识别<code>Resource</code>类型的依赖了。</p>
<h4 id="国际化信息支持"><a href="#国际化信息支持" class="headerlink" title="国际化信息支持"></a>国际化信息支持</h4><p>Locale和ResourceBundle</p>
<blockquote>
<p>Locale</p>
</blockquote>
<p>不同的<code>Locale</code>代表不同的国家和地区，每个国家和地区在Locale这里都有相应的简写代码表示，包括语言代码以及国家代码，这些代码是ISO标准代码。如，Locale.CHINA代表中国，它的代码表示为zh_CN；Locale.US代表美国地区，代码表示为en_US；而美国和英国等都属于英语地区，则可以使用Locale.ENGLISH来统一表示，这时代码只有语言代码，即en。</p>
<blockquote>
<p>ResourceBundle</p>
</blockquote>
<p><code>ResourceBundle</code>用来保存特定于某个Locale的信息（可以是String类型信息，也可以是任何类型的对象）。通常，ResourceBundle管理一组信息序列，所有的信息序列有统一的一个basename，然后特定的Locale的信息，可以根据basename后追加的语言或者地区代码来区分。</p>
<blockquote>
<p>MessageSource与ApplicationContext</p>
</blockquote>
<p>通过<code>MessageSource</code>接口，我们统一了国际化信息的访问方式。传入相应的Locale、资源的键以及相应参数，就可以取得相应的信息，再也不用先根据Locale取得ResourceBundle，然后再从ResourceBundle查询信息了。</p>
<p><strong><code>ApplicationContext</code>实现了<code>MessageSource</code>接口，也就是说它可以作为<code>MessageSource</code>使用</strong></p>
<p>在默认情况下，<code>ApplicationContext</code>将委派容器中一个名称为<code>messageSource</code>的<code>MessageSource</code>接口实现来完成<code>MessageSource</code>应该完成的职责。如果找不到这样一个名字的<code>MessageSource</code>实现，<code>ApplicationContext</code>内部会默认实例化一个不含任何内容的<code>StaticMessageSource</code>实例，以保证相应的方法调用。</p>
<p>常见的MessageSource实现类：</p>
<ul>
<li><code>StaticMessageSource</code>：MessageSource接口的简单实现，可以通过编程的方式添加信息条目，多用于测试，不应该用于正式的生产环境</li>
<li><code>ResourceBundleMessageSource</code>：基于标准的java.util.ResourceBundle而实现的MessageSource，对其父类AbstractMessageSource的行为进行了扩展，<strong>提供对多个ResourceBundle的缓存以提高查询速度</strong>。同时，<strong>对于参数化的信息和非参数化信息的处理进行了优化，并对用于参数化信息格式化的MessageFormat实例也进行了缓存</strong>。它是最常用的、用于正式生产环境下的MessageSource实现。</li>
<li><code>ReloadableResourceBundleMessageSource</code>：同样基于标准的java.util.ResourceBundle而构建的MessageSource实现类，但通过其cacheSeconds属性可以指定时间段，以定期刷新并检查底层的properties资源文件是否有变更。可以通过properties加载信息。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/img/image-20220502145840147.png" alt="MessageSource"></p>
<p><code>ApplicationContext</code>启动的时候，会自动识别容器中类型为<code>MessageSourceAware</code>的bean定义，并将自身作为<code>MessageSource</code>注入相应对象实例中。如果某个业务对象需要国际化的信息支持，那么最简单的办法就是让它实现<code>MessageSourceAware</code>接口，然后注册到<code>ApplicationContext</code>容器。不过这样一来，该业务对象对ApplicationContext容器的依赖性就太强了，显得容器具有较强的侵入性。</p>
<p>而实际上，如果真的某个业务对象需要依赖于<code>MessageSource</code>的话，直接<strong>通过构造方法注入或者setter方法注入的方式声明依赖</strong>就可以了。只要配置bean定义时，将<code>ApplicationContext</code>容器内部的那个<code>messageSource</code>注入该业务对象即可。</p>
<p>既然<code>MessageSource</code>可以独立使用，那为什么还让<code>ApplicationContext</code>实现该接口呢？在独立运行的应用程序（Standalone Application）中，就如我们上面这些应用场景所展示的那样，直接使用<code>MessageSource</code>的相应实现类就行了。不过<strong>在Web应用程序中</strong>，<strong>通常会公开ApplicationContext给视图（View）层</strong>，这样，<strong>通过标签（tag）就可以直接访问国际化信息了</strong>。</p>
<h4 id="容器内部事件发布"><a href="#容器内部事件发布" class="headerlink" title="容器内部事件发布"></a>容器内部事件发布</h4><p>自定义事件发布流程</p>
<ol>
<li><strong>给出自定义事件类型（define your own event object）</strong>。为了针对具体场景可以区分具体的事件类型，我们需要给出自己的事件类型的定义，通常做法是扩展java.util.EventObject类来实现自定义的事件类型。</li>
<li><strong>实现针对自定义事件类的事件监听器接口（define custom event listener）</strong>。自定义的事件监听器需要在合适的时机监听自定义的事件，事件监听器接口定义继承了java.util.EventListener。</li>
<li><strong>组合事件类和监听器，发布事件。</strong>有了自定义事件和自定义事件监听器，剩下的就是发布事件，然后让相应的监听器监听并处理事件了。通常情况下，我们会有一个事件发布者（EventPublisher），它本身作为事件源，会在合适的时点，将相应事件发布给对应的事件监听器。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/img/image-20220502150444234.png" alt="自定义事件" style="zoom:80%;" />





<blockquote>
<p>Spring容器内部事件发布</p>
</blockquote>
<p>Spring 的<code>ApplicationContext</code> 容器内部允许以org.springframework.context.<code>ApplicationEvent</code><br>的形式发布事件， 容器内注册的org.springframework.context.<code>ApplicationListener</code>类型的bean定义会被<code>ApplicationContext</code>容器自动识别，它们负责监听容器内发布的所有<code>ApplicationEvent</code>类型的事件。也就是说，一旦容器内发布<code>ApplicationEvent</code>及其子类型的事件，注册到容器的<code>ApplicationListener</code>就会对这些事件进行处理。</p>
<ul>
<li><p><code>ApplicationEvent</code>：</p>
<p>Spring容器内自定义事件类型，继承自java.util.EventObject，它是一个抽象类，需要根据情况提供相应子类以区分不同情况。</p>
<ul>
<li><code>ContextClosedEvent</code>：ApplicationContext容器在即将关闭的时候发布的事件类型。</li>
<li><code>ContextRefreshedEvent</code>：ApplicationContext容器在初始化或者刷新的时候发布的事件类型。</li>
<li><code>RequestHandledEvent</code>：Web请求处理后发布的事件，其有一子类ServletRequestHandledEvent提供特定于Java EE的Servlet相关事件</li>
</ul>
</li>
<li><p><code>ApplicationListener</code>：</p>
<p><code>ApplicationContext</code>容器内使用的自定义事件监听器接口定义，继承自java.util.<code>EventListener</code>。<code>ApplicationContext</code>容器在启动时，会自动识别并加载<code>EventListener</code>类型bean定义，一旦容器内有事件发布，将通知这些注册到容器的<code>EventListener</code>。</p>
</li>
<li><p><code>ApplicationContext</code>：</p>
<p><code>ApplicationContext</code>接口定义还继承了<code>ApplicationEventPublisher</code>接口，该接口提供了void publishEvent(ApplicationEvent event)方法定义。不难看出，<strong>ApplicationContext容器现在担当的就是事件发布者的角色</strong>。</p>
</li>
</ul>
<p><code>ApplicationContext</code>容器的具体实现类在实现事件的发布和事件监听器的注册方面，<strong>并没事必躬亲</strong>，而是把这些活儿<strong>转包</strong>给了一个称作org.springframework.context.event.<code>ApplicationEventMulticaster</code>的接口。<strong>该接口定义了具体事件监听器的注册管理以及事件发布的方法</strong>，但接口终归是接口，还得有具体实现。<code>ApplicationEventMulticaster</code>有一抽象实现类——org.springframework.<br>context.event.<code>AbstractApplicationEventMulticaster</code>，<strong>它实现了事件监听器的管理功能</strong>。出于灵活性和扩展性考虑，事件的发布功能则委托给了其子类。org.springframework.context.event.<code>SimpleApplicationEventMulticaster</code> 是Spring 提供的<code>AbstractApplicationEventMulticaster</code>的一个子类实现，<strong>添加了事件发布功能的实现</strong>。不过，其默认使用了<code>SyncTaskExecutor</code>进行事件的发布。与我们给出的样例事件发布者实现一样，<strong>事件是同步顺序发布的</strong>。为了避免这种方式可能存在的性能问题， 我们可以为其提供其他类型的<code>TaskExecutor</code> 实现类。<br>因为<code>ApplicationContext</code>容器的事件发布功能全部委托给了<code>ApplicationEventMulticaster</code>来做，所以，容器启动伊始，就会检查容器内是否存在名称为<code>applicationEventMulticaster</code>的<strong>ApplicationEventMulticaster对象实例</strong>。有的话就使用提供的实现，没有则默认初始化一个<code>SimpleApplicationEventMulticaster</code>作为将会使用的<code>ApplicationEventMulticaster</code>。3</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/img/image-20220502151807980.png" alt="Spring容器内部事件发布"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/06/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO/" title="Non-blocking I/O"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Non-blocking I/O</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CoderChen</div><div class="author-info__description">远赴人间惊鸿宴 一睹人间盛世颜</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Good good study, day day up!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E5%B0%8F%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Spring 小记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactoryProcessor"><span class="toc-number">1.0.1.</span> <span class="toc-text">BeanFactoryProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.0.2.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8EBeanWrapper"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">Bean的初始化与BeanWrapper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5Aware%E6%8E%A5%E5%8F%A3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">检查Aware接口并设置相关依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">BeanPostProcessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InitializingBean%E5%92%8Cinit-method"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">InitializingBean和init-method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DisposableBean%E4%B8%8Edestroy-method"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">DisposableBean与destroy-method</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext"><span class="toc-number">1.0.3.</span> <span class="toc-text">ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">统一的资源加载策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%AF%E6%8C%81"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">国际化信息支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">容器内部事件发布</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/12/hello-world/" title="Hello World"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2023/08/12/hello-world/" title="Hello World">Hello World</a><time datetime="2023-08-12T14:11:10.838Z" title="Created 2023-08-12 14:11:10">2023-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/07/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" title="前后端跨域问题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前后端跨域问题"/></a><div class="content"><a class="title" href="/2023/08/07/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" title="前后端跨域问题">前后端跨域问题</a><time datetime="2023-08-07T22:00:00.000Z" title="Created 2023-08-07 22:00:00">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/06/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/Swagger/" title="Swagger"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Swagger"/></a><div class="content"><a class="title" href="/2023/08/06/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/Swagger/" title="Swagger">Swagger</a><time datetime="2023-08-06T18:00:00.000Z" title="Created 2023-08-06 18:00:00">2023-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/RPC%E5%B0%8F%E8%AE%B0/" title="RPC小记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RPC小记"/></a><div class="content"><a class="title" href="/2022/07/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/RPC%E5%B0%8F%E8%AE%B0/" title="RPC小记">RPC小记</a><time datetime="2022-07-05T18:00:00.000Z" title="Created 2022-07-05 18:00:00">2022-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/18/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/" title="Netty优化与源码"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgs-1311962376.cos.ap-nanjing.myqcloud.com/cover_bg15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty优化与源码"/></a><div class="content"><a class="title" href="/2022/06/18/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Netty%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/" title="Netty优化与源码">Netty优化与源码</a><time datetime="2022-06-18T18:00:00.000Z" title="Created 2022-06-18 18:00:00">2022-06-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By CoderChen</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://chenxiniubi666.com/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>